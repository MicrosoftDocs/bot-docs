<Type Name="Expression" FullName="AdaptiveExpressions.Expression">
  <TypeSignature Language="C#" Value="public class Expression" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Expression extends System.Object" />
  <TypeSignature Language="DocId" Value="T:AdaptiveExpressions.Expression" />
  <TypeSignature Language="VB.NET" Value="Public Class Expression" />
  <TypeSignature Language="F#" Value="type Expression = class" />
  <AssemblyInfo>
    <AssemblyName>AdaptiveExpressions</AssemblyName>
    <AssemblyVersion>4.9.3.0</AssemblyVersion>
    <AssemblyVersion>4.10.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[Newtonsoft.Json.JsonConverter(typeof(AdaptiveExpressions.Converters.ExpressionConverter))]</AttributeName>
      <AttributeName Language="F#">[&lt;Newtonsoft.Json.JsonConverter(typeof(AdaptiveExpressions.Converters.ExpressionConverter))&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
            An expression which can be analyzed or evaluated to produce a value.
            </summary>
    <remarks>
            This provides an open-ended wrapper that supports a number of built-in functions and can also be extended at runtime.
            It also supports validation of the correctness of an expression and evaluation that should be exception free.
            </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Expression (AdaptiveExpressions.ExpressionEvaluator evaluator, params AdaptiveExpressions.Expression[] children);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class AdaptiveExpressions.ExpressionEvaluator evaluator, class AdaptiveExpressions.Expression[] children) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.#ctor(AdaptiveExpressions.ExpressionEvaluator,AdaptiveExpressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (evaluator As ExpressionEvaluator, ParamArray children As Expression())" />
      <MemberSignature Language="F#" Value="new AdaptiveExpressions.Expression : AdaptiveExpressions.ExpressionEvaluator * AdaptiveExpressions.Expression[] -&gt; AdaptiveExpressions.Expression" Usage="new AdaptiveExpressions.Expression (evaluator, children)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="evaluator" Type="AdaptiveExpressions.ExpressionEvaluator" />
        <Parameter Name="children" Type="AdaptiveExpressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="evaluator">Information about how to validate and evaluate expression.</param>
        <param name="children">Child expressions.</param>
        <summary>
            Initializes a new instance of the <see cref="T:AdaptiveExpressions.Expression" /> class.
            Expression constructor.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Expression (string type, params AdaptiveExpressions.Expression[] children);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string type, class AdaptiveExpressions.Expression[] children) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.#ctor(System.String,AdaptiveExpressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (type As String, ParamArray children As Expression())" />
      <MemberSignature Language="F#" Value="new AdaptiveExpressions.Expression : string * AdaptiveExpressions.Expression[] -&gt; AdaptiveExpressions.Expression" Usage="new AdaptiveExpressions.Expression (type, children)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="type" Type="System.String" />
        <Parameter Name="children" Type="AdaptiveExpressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">Type of built-in expression from <see cref="T:AdaptiveExpressions.ExpressionType" />.</param>
        <param name="children">Child expressions.</param>
        <summary>
            Initializes a new instance of the <see cref="T:AdaptiveExpressions.Expression" /> class.
            Built-in expression constructor.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Accessor">
      <MemberSignature Language="C#" Value="public static AdaptiveExpressions.Expression Accessor (string property, AdaptiveExpressions.Expression instance = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class AdaptiveExpressions.Expression Accessor(string property, class AdaptiveExpressions.Expression instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.Accessor(System.String,AdaptiveExpressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Accessor (property As String, Optional instance As Expression = Nothing) As Expression" />
      <MemberSignature Language="F#" Value="static member Accessor : string * AdaptiveExpressions.Expression -&gt; AdaptiveExpressions.Expression" Usage="AdaptiveExpressions.Expression.Accessor (property, instance)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>AdaptiveExpressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="System.String" />
        <Parameter Name="instance" Type="AdaptiveExpressions.Expression" />
      </Parameters>
      <Docs>
        <param name="property">Property to lookup.</param>
        <param name="instance">Expression to get instance that contains property or null for global state.</param>
        <summary>
            Construct and validate a property accessor.
            </summary>
        <returns>New expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AndExpression">
      <MemberSignature Language="C#" Value="public static AdaptiveExpressions.Expression AndExpression (params AdaptiveExpressions.Expression[] children);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class AdaptiveExpressions.Expression AndExpression(class AdaptiveExpressions.Expression[] children) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.AndExpression(AdaptiveExpressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndExpression (ParamArray children As Expression()) As Expression" />
      <MemberSignature Language="F#" Value="static member AndExpression : AdaptiveExpressions.Expression[] -&gt; AdaptiveExpressions.Expression" Usage="AdaptiveExpressions.Expression.AndExpression children" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>AdaptiveExpressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="children" Type="AdaptiveExpressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="children">Child clauses.</param>
        <summary>
            Construct and validate an And expression.
            </summary>
        <returns>New expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Children">
      <MemberSignature Language="C#" Value="public AdaptiveExpressions.Expression[] Children { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class AdaptiveExpressions.Expression[] Children" />
      <MemberSignature Language="DocId" Value="P:AdaptiveExpressions.Expression.Children" />
      <MemberSignature Language="VB.NET" Value="Public Property Children As Expression()" />
      <MemberSignature Language="F#" Value="member this.Children : AdaptiveExpressions.Expression[] with get, set" Usage="AdaptiveExpressions.Expression.Children" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>AdaptiveExpressions.Expression[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets or sets children expressions.
            </summary>
        <value>
            Children expressions.
            </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConstantExpression">
      <MemberSignature Language="C#" Value="public static AdaptiveExpressions.Expression ConstantExpression (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class AdaptiveExpressions.Expression ConstantExpression(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.ConstantExpression(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConstantExpression (value As Object) As Expression" />
      <MemberSignature Language="F#" Value="static member ConstantExpression : obj -&gt; AdaptiveExpressions.Expression" Usage="AdaptiveExpressions.Expression.ConstantExpression value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>AdaptiveExpressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Constant value.</param>
        <summary>
            Construct a constant expression.
            </summary>
        <returns>New expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeepEquals">
      <MemberSignature Language="C#" Value="public virtual bool DeepEquals (AdaptiveExpressions.Expression other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool DeepEquals(class AdaptiveExpressions.Expression other) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.DeepEquals(AdaptiveExpressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeepEquals (other As Expression) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member DeepEquals : AdaptiveExpressions.Expression -&gt; bool&#xA;override this.DeepEquals : AdaptiveExpressions.Expression -&gt; bool" Usage="expression.DeepEquals other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="AdaptiveExpressions.Expression" />
      </Parameters>
      <Docs>
        <param name="other">Other expression.</param>
        <summary>
            Do a deep equality between expressions.
            </summary>
        <returns>True if expressions are the same.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EqualsExpression">
      <MemberSignature Language="C#" Value="public static AdaptiveExpressions.Expression EqualsExpression (params AdaptiveExpressions.Expression[] children);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class AdaptiveExpressions.Expression EqualsExpression(class AdaptiveExpressions.Expression[] children) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.EqualsExpression(AdaptiveExpressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EqualsExpression (ParamArray children As Expression()) As Expression" />
      <MemberSignature Language="F#" Value="static member EqualsExpression : AdaptiveExpressions.Expression[] -&gt; AdaptiveExpressions.Expression" Usage="AdaptiveExpressions.Expression.EqualsExpression children" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>AdaptiveExpressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="children" Type="AdaptiveExpressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="children">Child clauses.</param>
        <summary>
            Construct and validate an Equals expression.
            </summary>
        <returns>New expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Evaluator">
      <MemberSignature Language="C#" Value="public AdaptiveExpressions.ExpressionEvaluator Evaluator { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class AdaptiveExpressions.ExpressionEvaluator Evaluator" />
      <MemberSignature Language="DocId" Value="P:AdaptiveExpressions.Expression.Evaluator" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Evaluator As ExpressionEvaluator" />
      <MemberSignature Language="F#" Value="member this.Evaluator : AdaptiveExpressions.ExpressionEvaluator" Usage="AdaptiveExpressions.Expression.Evaluator" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>AdaptiveExpressions.ExpressionEvaluator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets expression evaluator.
            </summary>
        <value>
            expression evaluator.
            </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Functions">
      <MemberSignature Language="C#" Value="public static readonly AdaptiveExpressions.Expression.FunctionTable Functions;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class AdaptiveExpressions.Expression/FunctionTable Functions" />
      <MemberSignature Language="DocId" Value="F:AdaptiveExpressions.Expression.Functions" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Functions As Expression.FunctionTable " />
      <MemberSignature Language="F#" Value=" staticval mutable Functions : AdaptiveExpressions.Expression.FunctionTable" Usage="AdaptiveExpressions.Expression.Functions" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>AdaptiveExpressions.Expression+FunctionTable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Dictionary of function =&gt; ExpressionEvaluator.
            </summary>
        <remarks>
            This is all available functions, you can add custom functions to it, but you cannot
            replace builtin functions.  If you clear the dictionary, it will be reset to the built in functions.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="LambaExpression">
      <MemberSignature Language="C#" Value="public static AdaptiveExpressions.Expression LambaExpression (AdaptiveExpressions.EvaluateExpressionDelegate function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class AdaptiveExpressions.Expression LambaExpression(class AdaptiveExpressions.EvaluateExpressionDelegate function) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.LambaExpression(AdaptiveExpressions.EvaluateExpressionDelegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LambaExpression (function As EvaluateExpressionDelegate) As Expression" />
      <MemberSignature Language="F#" Value="static member LambaExpression : AdaptiveExpressions.EvaluateExpressionDelegate -&gt; AdaptiveExpressions.Expression" Usage="AdaptiveExpressions.Expression.LambaExpression function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>AdaptiveExpressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="AdaptiveExpressions.EvaluateExpressionDelegate" />
      </Parameters>
      <Docs>
        <param name="function">Function to create an expression from.</param>
        <summary>
            Construct an expression from a <see cref="T:AdaptiveExpressions.EvaluateExpressionDelegate" />.
            </summary>
        <returns>New expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static AdaptiveExpressions.Expression Lambda (Func&lt;object,object&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class AdaptiveExpressions.Expression Lambda(class System.Func`2&lt;object, object&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.Lambda(System.Func{System.Object,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (function As Func(Of Object, Object)) As Expression" />
      <MemberSignature Language="F#" Value="static member Lambda : Func&lt;obj, obj&gt; -&gt; AdaptiveExpressions.Expression" Usage="AdaptiveExpressions.Expression.Lambda function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>AdaptiveExpressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,System.Object&gt;" />
      </Parameters>
      <Docs>
        <param name="function">Lambda expression to evaluate.</param>
        <summary>
            Construct an expression from a lambda expression over the state.
            </summary>
        <returns>New expression.</returns>
        <remarks>Exceptions will be caught and surfaced as an error string.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lookup">
      <MemberSignature Language="C#" Value="public static AdaptiveExpressions.ExpressionEvaluator Lookup (string functionName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class AdaptiveExpressions.ExpressionEvaluator Lookup(string functionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.Lookup(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lookup (functionName As String) As ExpressionEvaluator" />
      <MemberSignature Language="F#" Value="static member Lookup : string -&gt; AdaptiveExpressions.ExpressionEvaluator" Usage="AdaptiveExpressions.Expression.Lookup functionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>AdaptiveExpressions.ExpressionEvaluator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="functionName">function name.</param>
        <summary>
            Lookup a ExpressionEvaluator (function) by name.
            </summary>
        <returns>ExpressionEvaluator.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeExpression">
      <MemberSignature Language="C#" Value="public static AdaptiveExpressions.Expression MakeExpression (AdaptiveExpressions.ExpressionEvaluator evaluator, params AdaptiveExpressions.Expression[] children);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class AdaptiveExpressions.Expression MakeExpression(class AdaptiveExpressions.ExpressionEvaluator evaluator, class AdaptiveExpressions.Expression[] children) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.MakeExpression(AdaptiveExpressions.ExpressionEvaluator,AdaptiveExpressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeExpression (evaluator As ExpressionEvaluator, ParamArray children As Expression()) As Expression" />
      <MemberSignature Language="F#" Value="static member MakeExpression : AdaptiveExpressions.ExpressionEvaluator * AdaptiveExpressions.Expression[] -&gt; AdaptiveExpressions.Expression" Usage="AdaptiveExpressions.Expression.MakeExpression (evaluator, children)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>AdaptiveExpressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evaluator" Type="AdaptiveExpressions.ExpressionEvaluator" />
        <Parameter Name="children" Type="AdaptiveExpressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="evaluator">Information about how to validate and evaluate expression.</param>
        <param name="children">Child expressions.</param>
        <summary>
            Make an expression and validate it.
            </summary>
        <returns>New expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeExpression">
      <MemberSignature Language="C#" Value="public static AdaptiveExpressions.Expression MakeExpression (string type, params AdaptiveExpressions.Expression[] children);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class AdaptiveExpressions.Expression MakeExpression(string type, class AdaptiveExpressions.Expression[] children) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.MakeExpression(System.String,AdaptiveExpressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeExpression (type As String, ParamArray children As Expression()) As Expression" />
      <MemberSignature Language="F#" Value="static member MakeExpression : string * AdaptiveExpressions.Expression[] -&gt; AdaptiveExpressions.Expression" Usage="AdaptiveExpressions.Expression.MakeExpression (type, children)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>AdaptiveExpressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.String" />
        <Parameter Name="children" Type="AdaptiveExpressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">Type of expression from <see cref="T:AdaptiveExpressions.ExpressionType" />.</param>
        <param name="children">Child expressions.</param>
        <summary>
            Make an expression and validate it.
            </summary>
        <returns>New expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NotExpression">
      <MemberSignature Language="C#" Value="public static AdaptiveExpressions.Expression NotExpression (AdaptiveExpressions.Expression child);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class AdaptiveExpressions.Expression NotExpression(class AdaptiveExpressions.Expression child) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.NotExpression(AdaptiveExpressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NotExpression (child As Expression) As Expression" />
      <MemberSignature Language="F#" Value="static member NotExpression : AdaptiveExpressions.Expression -&gt; AdaptiveExpressions.Expression" Usage="AdaptiveExpressions.Expression.NotExpression child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>AdaptiveExpressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="AdaptiveExpressions.Expression" />
      </Parameters>
      <Docs>
        <param name="child">Child clauses.</param>
        <summary>
            Construct and validate a Not expression.
            </summary>
        <returns>New expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator AdaptiveExpressions.Expression (string expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class AdaptiveExpressions.Expression op_Implicit(string expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.op_Implicit(System.String)~AdaptiveExpressions.Expression" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (expression As String) As Expression" />
      <MemberSignature Language="F#" Value="static member op_Implicit : string -&gt; AdaptiveExpressions.Expression" Usage="AdaptiveExpressions.Expression.op_Implicit expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>AdaptiveExpressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">string expression.</param>
        <summary>
            allow a string to be implicitly assigned to an expression property.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OrExpression">
      <MemberSignature Language="C#" Value="public static AdaptiveExpressions.Expression OrExpression (params AdaptiveExpressions.Expression[] children);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class AdaptiveExpressions.Expression OrExpression(class AdaptiveExpressions.Expression[] children) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.OrExpression(AdaptiveExpressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrExpression (ParamArray children As Expression()) As Expression" />
      <MemberSignature Language="F#" Value="static member OrExpression : AdaptiveExpressions.Expression[] -&gt; AdaptiveExpressions.Expression" Usage="AdaptiveExpressions.Expression.OrExpression children" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>AdaptiveExpressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="children" Type="AdaptiveExpressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="children">Child clauses.</param>
        <summary>
            Construct and validate an Or expression.
            </summary>
        <returns>New expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static AdaptiveExpressions.Expression Parse (string expression, AdaptiveExpressions.EvaluatorLookup lookup = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class AdaptiveExpressions.Expression Parse(string expression, class AdaptiveExpressions.EvaluatorLookup lookup) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.Parse(System.String,AdaptiveExpressions.EvaluatorLookup)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (expression As String, Optional lookup As EvaluatorLookup = Nothing) As Expression" />
      <MemberSignature Language="F#" Value="static member Parse : string * AdaptiveExpressions.EvaluatorLookup -&gt; AdaptiveExpressions.Expression" Usage="AdaptiveExpressions.Expression.Parse (expression, lookup)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>AdaptiveExpressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.String" />
        <Parameter Name="lookup" Type="AdaptiveExpressions.EvaluatorLookup" />
      </Parameters>
      <Docs>
        <param name="expression">expression string.</param>
        <param name="lookup">Optional function lookup when parsing the expression. Default is Expression.Lookup which uses Expression.Functions table.</param>
        <summary>
            Parse an expression string into an expression object.
            </summary>
        <returns>expression object.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="References">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IReadOnlyList&lt;string&gt; References ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IReadOnlyList`1&lt;string&gt; References() cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.References" />
      <MemberSignature Language="VB.NET" Value="Public Function References () As IReadOnlyList(Of String)" />
      <MemberSignature Language="F#" Value="member this.References : unit -&gt; System.Collections.Generic.IReadOnlyList&lt;string&gt;" Usage="expression.References " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Return the static reference paths to memory.
            </summary>
        <returns>List of the static reference paths.</returns>
        <remarks>
            Return all static paths to memory.  If there is a computed element index, then the path is terminated there,
            but you might get other paths from the computed part as well.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceWalk">
      <MemberSignature Language="C#" Value="public (string,System.Collections.Generic.HashSet&lt;string&gt;) ReferenceWalk (AdaptiveExpressions.Expression expression, Func&lt;AdaptiveExpressions.Expression,bool&gt; extension = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.ValueTuple`2&lt;string, class System.Collections.Generic.HashSet`1&lt;string&gt;&gt; ReferenceWalk(class AdaptiveExpressions.Expression expression, class System.Func`2&lt;class AdaptiveExpressions.Expression, bool&gt; extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.ReferenceWalk(AdaptiveExpressions.Expression,System.Func{AdaptiveExpressions.Expression,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="Public Function ReferenceWalk (expression As Expression, Optional extension As Func(Of Expression, Boolean) = Nothing) As ValueTuple(Of String, HashSet(Of String))" />
      <MemberSignature Language="F#" Value="member this.ReferenceWalk : AdaptiveExpressions.Expression * Func&lt;AdaptiveExpressions.Expression, bool&gt; -&gt; ValueTuple&lt;string, System.Collections.Generic.HashSet&lt;string&gt;&gt;" Usage="expression.ReferenceWalk (expression, extension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ValueTuple&lt;System.String,System.Collections.Generic.HashSet&lt;System.String&gt;&gt;</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "path", "references" })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "path", "references" })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="AdaptiveExpressions.Expression" />
        <Parameter Name="extension" Type="System.Func&lt;AdaptiveExpressions.Expression,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <param name="expression">Expression to analyze.</param>
        <param name="extension">If present, called to override lookup for things like template expansion.</param>
        <summary>
            Walking function for identifying static memory references in an expression.
            </summary>
        <returns>Accessor path of expression which is a potential partial path and the full path found so far.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnType">
      <MemberSignature Language="C#" Value="public AdaptiveExpressions.ReturnType ReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype AdaptiveExpressions.ReturnType ReturnType" />
      <MemberSignature Language="DocId" Value="P:AdaptiveExpressions.Expression.ReturnType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReturnType As ReturnType" />
      <MemberSignature Language="F#" Value="member this.ReturnType : AdaptiveExpressions.ReturnType" Usage="AdaptiveExpressions.Expression.ReturnType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>AdaptiveExpressions.ReturnType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets expected result of evaluating expression.
            </summary>
        <value>
            Expected result of evaluating expression.
            </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetPathToValue">
      <MemberSignature Language="C#" Value="public static AdaptiveExpressions.Expression SetPathToValue (AdaptiveExpressions.Expression property, AdaptiveExpressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class AdaptiveExpressions.Expression SetPathToValue(class AdaptiveExpressions.Expression property, class AdaptiveExpressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.SetPathToValue(AdaptiveExpressions.Expression,AdaptiveExpressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetPathToValue (property As Expression, value As Expression) As Expression" />
      <MemberSignature Language="F#" Value="static member SetPathToValue : AdaptiveExpressions.Expression * AdaptiveExpressions.Expression -&gt; AdaptiveExpressions.Expression" Usage="AdaptiveExpressions.Expression.SetPathToValue (property, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>AdaptiveExpressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="AdaptiveExpressions.Expression" />
        <Parameter Name="value" Type="AdaptiveExpressions.Expression" />
      </Parameters>
      <Docs>
        <param name="property">property expression.</param>
        <param name="value">value expression.</param>
        <summary>
            Construct and validate an Set a property expression to a value expression.
            </summary>
        <returns>New expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetPathToValue">
      <MemberSignature Language="C#" Value="public static AdaptiveExpressions.Expression SetPathToValue (AdaptiveExpressions.Expression property, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class AdaptiveExpressions.Expression SetPathToValue(class AdaptiveExpressions.Expression property, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.SetPathToValue(AdaptiveExpressions.Expression,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetPathToValue (property As Expression, value As Object) As Expression" />
      <MemberSignature Language="F#" Value="static member SetPathToValue : AdaptiveExpressions.Expression * obj -&gt; AdaptiveExpressions.Expression" Usage="AdaptiveExpressions.Expression.SetPathToValue (property, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>AdaptiveExpressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="AdaptiveExpressions.Expression" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="property">property expression.</param>
        <param name="value">value object.</param>
        <summary>
            Construct and validate an Set a property expression to a value expression.
            </summary>
        <returns>New expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="expression.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Returns a string that represents the current object.
            </summary>
        <returns>A string value of this Expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryEvaluate">
      <MemberSignature Language="C#" Value="public (object,string) TryEvaluate (AdaptiveExpressions.Memory.IMemory state, AdaptiveExpressions.Options options = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.ValueTuple`2&lt;object, string&gt; TryEvaluate(class AdaptiveExpressions.Memory.IMemory state, class AdaptiveExpressions.Options options) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.TryEvaluate(AdaptiveExpressions.Memory.IMemory,AdaptiveExpressions.Options)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEvaluate (state As IMemory, Optional options As Options = Nothing) As ValueTuple(Of Object, String)" />
      <MemberSignature Language="F#" Value="member this.TryEvaluate : AdaptiveExpressions.Memory.IMemory * AdaptiveExpressions.Options -&gt; ValueTuple&lt;obj, string&gt;" Usage="expression.TryEvaluate (state, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ValueTuple&lt;System.Object,System.String&gt;</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "value", "error" })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "value", "error" })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="AdaptiveExpressions.Memory.IMemory" />
        <Parameter Name="options" Type="AdaptiveExpressions.Options" />
      </Parameters>
      <Docs>
        <param name="state">
            Global state to evaluate accessor expressions against.  Can be <see cref="T:System.Collections.Generic.IDictionary`2" />,
            <see cref="T:System.Collections.IDictionary" /> otherwise reflection is used to access property and then indexer.
            </param>
        <param name="options">Options used in the evaluation. </param>
        <summary>
            Evaluate the expression.
            </summary>
        <returns>Computed value and an error string.  If the string is non-null, then there was an evaluation error.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryEvaluate">
      <MemberSignature Language="C#" Value="public (object,string) TryEvaluate (object state, AdaptiveExpressions.Options options = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.ValueTuple`2&lt;object, string&gt; TryEvaluate(object state, class AdaptiveExpressions.Options options) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.TryEvaluate(System.Object,AdaptiveExpressions.Options)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEvaluate (state As Object, Optional options As Options = Nothing) As ValueTuple(Of Object, String)" />
      <MemberSignature Language="F#" Value="member this.TryEvaluate : obj * AdaptiveExpressions.Options -&gt; ValueTuple&lt;obj, string&gt;" Usage="expression.TryEvaluate (state, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ValueTuple&lt;System.Object,System.String&gt;</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "value", "error" })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "value", "error" })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="options" Type="AdaptiveExpressions.Options" />
      </Parameters>
      <Docs>
        <param name="state">
            Global state to evaluate accessor expressions against.  Can be <see cref="T:System.Collections.Generic.IDictionary`2" />,
            <see cref="T:System.Collections.IDictionary" /> otherwise reflection is used to access property and then indexer.
            </param>
        <param name="options">Options used in the evaluation. </param>
        <summary>
            Evaluate the expression.
            </summary>
        <returns>Computed value and an error string.  If the string is non-null, then there was an evaluation error.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryEvaluate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public (T,string) TryEvaluate&lt;T&gt; (AdaptiveExpressions.Memory.IMemory state, AdaptiveExpressions.Options options = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.ValueTuple`2&lt;!!T, string&gt; TryEvaluate&lt;T&gt;(class AdaptiveExpressions.Memory.IMemory state, class AdaptiveExpressions.Options options) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.TryEvaluate``1(AdaptiveExpressions.Memory.IMemory,AdaptiveExpressions.Options)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEvaluate(Of T) (state As IMemory, Optional options As Options = Nothing) As ValueTuple(Of T, String)" />
      <MemberSignature Language="F#" Value="member this.TryEvaluate : AdaptiveExpressions.Memory.IMemory * AdaptiveExpressions.Options -&gt; ValueTuple&lt;'T, string&gt;" Usage="expression.TryEvaluate (state, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ValueTuple&lt;T,System.String&gt;</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "value", "error" })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "value", "error" })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="state" Type="AdaptiveExpressions.Memory.IMemory" />
        <Parameter Name="options" Type="AdaptiveExpressions.Options" />
      </Parameters>
      <Docs>
        <typeparam name="T">type of result of the expression.</typeparam>
        <param name="state">
            Global state to evaluate accessor expressions against.  Can be <see cref="T:System.Collections.Generic.IDictionary`2" />,
            <see cref="T:System.Collections.IDictionary" /> otherwise reflection is used to access property and then indexer.
            </param>
        <param name="options">Options used in the evaluation. </param>
        <summary>
            Evaluate the expression.
            </summary>
        <returns>Computed value and an error string.  If the string is non-null, then there was an evaluation error.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryEvaluate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public (T,string) TryEvaluate&lt;T&gt; (object state, AdaptiveExpressions.Options options = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.ValueTuple`2&lt;!!T, string&gt; TryEvaluate&lt;T&gt;(object state, class AdaptiveExpressions.Options options) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.TryEvaluate``1(System.Object,AdaptiveExpressions.Options)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEvaluate(Of T) (state As Object, Optional options As Options = Nothing) As ValueTuple(Of T, String)" />
      <MemberSignature Language="F#" Value="member this.TryEvaluate : obj * AdaptiveExpressions.Options -&gt; ValueTuple&lt;'T, string&gt;" Usage="expression.TryEvaluate (state, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ValueTuple&lt;T,System.String&gt;</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "value", "error" })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "value", "error" })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="options" Type="AdaptiveExpressions.Options" />
      </Parameters>
      <Docs>
        <typeparam name="T">type of result of the expression.</typeparam>
        <param name="state">
            Global state to evaluate accessor expressions against.  Can be <see cref="T:System.Collections.Generic.IDictionary`2" />,
            <see cref="T:System.Collections.IDictionary" /> otherwise reflection is used to access property and then indexer.
            </param>
        <param name="options">Options used in the evaluation. </param>
        <summary>
            Evaluate the expression.
            </summary>
        <returns>Computed value and an error string.  If the string is non-null, then there was an evaluation error.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public string Type { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Type" />
      <MemberSignature Language="DocId" Value="P:AdaptiveExpressions.Expression.Type" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Type As String" />
      <MemberSignature Language="F#" Value="member this.Type : string" Usage="AdaptiveExpressions.Expression.Type" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets type of expression.
            </summary>
        <value>
            Type of expression.
            </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public void Validate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Validate() cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.Validate" />
      <MemberSignature Language="VB.NET" Value="Public Sub Validate ()" />
      <MemberSignature Language="F#" Value="member this.Validate : unit -&gt; unit" Usage="expression.Validate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Validate immediate expression.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateTree">
      <MemberSignature Language="C#" Value="public void ValidateTree ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateTree() cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.ValidateTree" />
      <MemberSignature Language="VB.NET" Value="Public Sub ValidateTree ()" />
      <MemberSignature Language="F#" Value="member this.ValidateTree : unit -&gt; unit" Usage="expression.ValidateTree " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Recursively validate the expression tree.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
